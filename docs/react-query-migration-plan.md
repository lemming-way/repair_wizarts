# План миграции Redux → React Query

Ниже — последовательность шагов с промтами для агента и контрольными проверками после каждого этапа. Перед началом убедись, что работаешь из актуальной ветки и что `npm install` уже выполнен.

## Шаг 1. Инвентаризация текущего Redux-состояния
**Промт для агента**
> Проанализируй все срезы Redux (`user`, `services`, `categories`, `online`, `messages`, `notifications`, `ui`). Построй таблицу или список «срез → потребители», отметь, какие данные загружаются с сервера, какие являются чисто клиентскими. Зафиксируй текущие точки входа (`fetchUser`, `fetchServices`, `setCategories`, и т.д.), описав, где они вызываются и какие побочные эффекты имеют (локальное кэширование, редиректы, очистка).

**Базовые проверки после шага**
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test -- --watchAll=false`

## Шаг 2. Подготовка инфраструктуры React Query
**Промт для агента**
> Убедись, что в проекте есть единый `QueryClient` и провайдер. При необходимости донастрой логгеры, Devtools (только в дев-режиме) и обработку ошибок. Создай или дополни слой API-клиентов (`src/services/api/*`), подготовь директорию для ключей запросов (`src/queries` или аналог). Обнови утилиты, чтобы компоненты использовали общие ключи и функции получения данных.

**Базовые проверки после шага**
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test -- --watchAll=false`

## Шаг 3. Миграция пользовательских данных на React Query
**Промт для агента**
> Перенеси загрузку пользователя с `createAsyncThunk` на `useQuery`. Реализуй хук `useUserQuery`, адаптируй потребителей (включая `App`). Обработай зависимости от токена (`enabled`). Настрой инвалидирование после мутаций и убери устаревший thunk/редьюсер из Redux, если он больше не используется.

**Базовые проверки после шага**
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test -- --watchAll=false`

## Шаг 4. Миграция сервисов и категорий
**Промт для агента**
> Создай `useServicesQuery` и `useCategoriesQuery`, перенеси загрузку соответствующих данных на React Query. Учитывай начальные данные из `localStorage` (используй `initialData`/`placeholderData`). После миграции удали дублирующие Redux-срезы и обнови компоненты, использующие эти данные.

**Базовые проверки после шага**
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test -- --watchAll=false`

## Шаг 5. Перенос остальных серверных фич и мутаций
**Промт для агента**
> По приоритету перенеси остальные серверные запросы (уведомления, чаты, справочники и т.д.) на React Query. Для мутаций используй `useMutation` и инвалидируй связанные ключи. Оцени необходимость сохранения WebSocket-слоя в Redux и наметь стратегию его интеграции с React Query (или временного сосуществования).

**Базовые проверки после шага**
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test -- --watchAll=false`

## Шаг 6. Очистка Redux и финальная стабилизация
**Промт для агента**
> После переноса всех серверных данных удали неиспользуемые редьюсеры, `Provider`, зависимости `react-redux`/`@reduxjs/toolkit`. При необходимости замени оставшееся клиентское состояние на более лёгкие механизмы (React Context, локальные хуки, `useQuery` с `setQueryData`). Обнови тесты, документацию и убедись, что приложение стабильно.

**Базовые проверки после шага**
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test -- --watchAll=false`

_Статус:_ Выполнено — клиентское состояние перенесено в `UIStateProvider`/`NotificationsProvider`, а WebSocket уведомления работают через контекстные обработчики вместо Redux middleware.【F:src/state/ui/UIStateContext.tsx†L5-L102】【F:src/state/notifications/NotificationsContext.tsx†L1-L79】【F:src/services/notification.service.js†L1-L162】

## Общие рекомендации
- После каждого шага фиксируй изменения в отдельном коммите, чтобы упростить откат.
- Если какой-то шаг оказывается слишком объёмным, разбей его на подшаги с теми же проверками.
- В финале проведи ручной смоук-тест ключевых сценариев (авторизация, просмотр услуг, управление профилем).
